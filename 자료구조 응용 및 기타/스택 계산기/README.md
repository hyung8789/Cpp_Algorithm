# 스택 계산기 (Infix Expression, Postfix Expression Calculator)

##	< 중위 표기식을 후위 표기식으로 변환 >

> 중위 표기식에서 연산 우선순위를 위한 괄호를 최우선적으로 처리하여야 함

> '(' 및 ')'는 변환 된 후위 표기식의 결과로서 출력하지 않음

    1) 사용자로부터 중위 표기식 입력

    2) 중위 표기식의 왼쪽부터 순차적으로 토큰 분리 (괄호, 피연산자 간 구분을 위한 공백, 피연산자, 연산자)
	: 토큰 분리 시 '.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 기호 타입의 토큰으로 처리

	3) 현재 분리 된 토큰의 기호 타입에 따라,

		3-1) '(' 인 경우
		: 현재 분리 된 토큰의 기호를 스택에 삽입

		3-2) ')' 인 경우
		: 현재 스택에서 '(' 가 맨 처음으로 나올 때 까지 노드의 기호를 꺼내어 순차적으로 변환 된 후위 표기식의 결과로서 출력
		('(' 가 한 번 나오지 않을 경우 잘못 된 중위 표기식 예외 발생)

		3-3) 연산자 ('+', '-', '*', '/') 인 경우
		: 우선순위가 높은 연산자에 대해 먼저 계산을 위해, 후위 표기식의 결과로서 출력 위한 연산자 우선순위 판별 수행
		더 이상 스택에 현재 토큰의 기호 타입보다 높은 우선순위를 가진 기호 타입이 존재하지 않게 되는 시점에 현재 분리 된 토큰의 기호를 스택에 삽입

			3-3-1) 현재 스택의 최상위 노드의 기호 타입에 대한 우선순위 >= 현재 분리 된 토큰의 기호 타입에 대한 우선순위
			: 우선순위가 높은 연산자에 대해 먼저 계산을 위해, 현재 스택의 최상위 노드를 스택에서 꺼내 해당 기호를 변환 된 후위 표기식의 결과로서 출력
			(단, 현재 스택의 최상의 노드의 기호가 '(' 일 경우, 변환 된 후위 표기식의 결과로서 출력하지 않음)

			3-3-2) 현재 스택의 최상위 노드의 기호 타입에 대한 우선순위 < 현재 분리 된 토큰의 기호 타입에 대한 우선순위
			: 우선순위가 높은 기호에 대해 먼저 계산을 위해 후위 표기식의 결과로서 출력 위한 판별 중지

		3-4) 피연산자 (정수 혹은 '.'을 포함 한 실수), ' ' (피연산자 간 구분을 위한 공백) 인 경우
		: 현재 분리 된 토큰의 기호를 스택에 삽입하지 않고 즉시 변환 된 후위 표기식의 결과로서 출력

		3-5) '.' (실수 표현을 위한 점) 인 경우
		: '.'은 단일 토큰으로서 처리 되지 않으며, '.'을 포함 한 실수로서 하나의 피연산자로 처리되어야만 함
		이에 따라, 논리 예외 발생

	4) 현재 중위 표기식에 더 이상 토큰으로 분리 할 것이 없으면, 스택에 남은 노드의 기호들을 순차적으로 모두 변환 된 후위 표기식의 결과로서 출력
	: 올바른 중위 표기식은 항상 '('와 ')'의 쌍이 일치 (개수가 일치)해야만 히며, 중위 표기식을 후위 표기식으로 변환하는 과정에서 ')'가 나올 경우, 
	'('가 나올 때 까지 후위 표기식에 출력하므로, 현재 스택에 남은 노드들 중 '('이 존재 할 경우, 잘못 된 중위 표기식 예외 발생

## < 대상 표현식 (Infix Expression, Postfix Expression) 으로부터 토큰 생성 >

	1) 대상 표현식에 대해 다 읽거나, 스택에 삽입 위하여 읽기 중지 시 까지 반복

	2) 현재 읽은 문자의 기호 타입에 따라,

		2-1) 현재 읽은 문자의 기호 타입이 피연산자인 경우
		: 현재 문자의 다음 문자가 존재하며, 현재 문자의 다음 문자의 기호 타입이 피연산자, 실수 표현을 위한 '.'이면 계속 읽기
		현재 문자의 다음 문자가 존재하며, 현재 문자의 다음 문자의 기호 타입이 피연산자, 실수 표현을 위한 '.'이 아닐 경우 스택에 삽입 위하여 읽기 중지
		('.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 토큰으로 처리)

		2-2) 현재 읽은 문자의 기호 타입이 실수 표현을 위한 '.'인 경우
		: 현재 문자의 이전, 다음 문자가 존재하며, 현재 문자의 이전, 다음 문자가 피연산자이면 계속 읽기
		현재 문자의 이전, 다음 문자가 존재하지 않거나, 현재 문자의 이전, 다음 문자가 피연산자가 아닐 경우 잘못 된 표현식 예외 발생
		'.'이 이미 이전에 존재하였을 경우 잘못 된 표현식 예외 발생

		2-3) 현재 읽은 문자의 기호 타입이 '(', ')', 연산자, 피연산자 간 구분을 위한 공백인 경우
		: 스택에 삽입 혹은 기타 처리를 위하여 읽기 중지

	---

	< '.'을 포함하는 실수의 조건 >

	1) '.'은 '.'을 포함하는 실수에서 맨 처음에 단독으로 존재 할 수 없으며, 어떠한 피연산자가 최소 한 번은 존재 한 다음에만 존재
	2) '.'은 '.'을 포함하는 실수에서 반드시 한 번만 존재
	3) '.'을 포함하는 실수에서 '.'이 존재한 뒤, 피연산자가 최소 한 번은 반드시 존재하여야 하고,
	최소 한 번 이상의 피연산자가 존재 후 더 이상 피연산자가 존재하지 않을 경우,
	이 전체를 하나의 실수로 간주하여 '.' 및 피연산자를 포함 한 하나의 피연산자 토큰으로 처리

## < 후위 표기식에 대한 처리 및 계산 >

> 후위 표기식 : 중위 표기식으로부터 '(', ')' 및 연산자 우선순위에 따라 변환

> '.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 토큰으로 처리하였으므로, 2-2에서 처리

	ex :
	중위 표기식 : ((1 - 2 * 2) + 1) * 3
	변환 된 후위 표기식 : 122*-1+3*

	1) 왼쪽부터 순차적으로 토큰 분리 (피연산자 간 구분을 위한 공백, 피연산자, 연산자)

	2) 분리 된 토큰의 기호 타입에 따라,
		2-1) 피연산자 간 구분을 위한 공백인 경우
		: 계산 시에 사용하지 않으므로, 해당 토큰 무시

		2-2) 피연산자인 경우
		: 토큰을 스택에 삽입

		2-3) 연산자인 경우
		: 스택에 존재하는 피연산자를 2회 꺼낸 후 피연산자에 대해 역순으로 현재 토큰의 연산자와 계산 수행 및 계산 결과를 다시 스택에 삽입
		단, 올바른 후위 표기식은 분리 된 토큰이 연산자인 상황에서 계산을 위해 스택에서 2회 꺼냈을 시, 항상 피연산자가 2회 연속으로 나타나야 함
		이에 따라, 스택에서 노드를 2회 꺼낼 수 없을 경우 (ex : 1*+2), 잘못 된 후위 표기식 예외 발생

	3) 후위 표기식을 끝까지 읽었을 경우 현재 스택에 남아있는 최종 계산 결과 반환