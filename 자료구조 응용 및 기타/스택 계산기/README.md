# 스택 계산기 (Infix Expression Stack Calculator)

## < 중위 표현식 혹은 후위 표현식 (Infix Expression, Postfix Expression) 으로부터 토큰 생성 >

> '.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 토큰으로 처리

	< '.'을 포함하는 실수의 조건 >

	1) '.'은 '.'을 포함하는 실수에서 맨 처음에 단독으로 존재 할 수 없으며, 어떠한 피연산자가 최소 한 번은 존재 한 다음에만 존재
	
	2) '.'은 '.'을 포함하는 실수에서 반드시 한 번만 존재
	
	3) '.'을 포함하는 실수에서 '.'이 존재한 뒤, 피연산자가 최소 한 번은 반드시 존재하여야 하고,
	최소 한 번 이상의 피연산자가 존재 후 더 이상 피연산자가 존재하지 않을 경우,
	이 전체를 하나의 실수로 간주하여 '.' 및 피연산자를 포함 한 하나의 피연산자 토큰으로 처리
	
	---

	1) 대상 표현식에 대해 다 읽거나, 현재까지 읽은 문자에 대해 처리를 위하여 읽기 중지가 발생하는 시점까지 반복

	2) 현재 읽은 문자의 기호 타입에 따라,

		2-1) 현재 읽은 문자의 기호 타입이 피연산자인 경우
			2-1-1) 현재 문자의 다음 문자가 존재하며, 현재 문자의 다음 문자의 기호 타입이 피연산자, 실수 표현을 위한 '.'인 경우
			: 계속 읽기

			2-1-2) 현재 문자의 다음 문자가 존재하며, 현재 문자의 다음 문자의 기호 타입이 피연산자, 실수 표현을 위한 '.'이 아닐 경우
			: 현재까지 읽은 문자에 대해 처리를 위하여 읽기 중지 (오른쪽에서 왼쪽으로 읽었을 경우, 현재까지 읽은 문자 좌우반전)

		2-2) 현재 읽은 문자의 기호 타입이 실수 표현을 위한 '.'인 경우 (이미 '.'가 존재하거나, 현재 문자의 이전, 다음 문자가 존재하지 않을 경우 잘못 된 표현식 예외 발생)
			2-2-1) 현재 문자의 이전, 다음 문자가 존재하며, 현재 문자의 이전, 다음 문자가 피연산자이면
			: 계속 읽기

			2-2-2) 현재 문자의 이전, 다음 문자가 존재하지 않거나, 현재 문자의 이전, 다음 문자가 피연산자가 아닐 경우
			: 잘못 된 표현식 예외 발생

		2-3) 현재 읽은 문자의 기호 타입이 ' ' (피연산자 간 구분을 위한 공백), '(', ')', 연산자인 경우
		: 현재 읽은 문자에 대해 처리를 위하여 읽기 중지

##	< 중위 표현식을 후위 표현식으로 변환 >

> 중위 표현식에서 연산 우선순위를 위한 괄호를 최우선적으로 처리하여야 함

> '(' 및 ')'는 변환 된 후위 표현식의 결과로서 출력하지 않음

    1) 사용자로부터 중위 표현식 입력

    2) 중위 표현식의 왼쪽부터 순차적으로 토큰 분리 (괄호, 피연산자 간 구분을 위한 공백, 피연산자, 연산자)
	: 토큰 분리 시 '.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 기호 타입의 토큰으로 처리

	3) 현재 분리 된 토큰의 기호 타입에 따라,

		3-1) '(' 인 경우
		: 현재 분리 된 토큰의 기호를 스택에 삽입

		3-2) ')' 인 경우
		: 현재 스택에서 '(' 가 맨 처음으로 나올 때 까지 노드의 기호를 꺼내어 순차적으로 변환 된 후위 표현식의 결과로서 출력
		('(' 가 한 번 나오지 않을 경우 잘못 된 중위 표현식 예외 발생)

		3-3) 연산자 ('+', '-', '*', '/') 인 경우
		: 우선순위가 높은 연산자에 대해 먼저 계산을 위해, 후위 표현식의 결과로서 출력 위한 연산자 우선순위 판별 수행
		더 이상 스택에 현재 토큰의 기호 타입보다 높은 우선순위를 가진 기호 타입이 존재하지 않게 되는 시점에 현재 분리 된 토큰의 기호를 스택에 삽입

			3-3-1) 현재 스택의 최상위 노드의 기호 타입에 대한 우선순위 >= 현재 분리 된 토큰의 기호 타입에 대한 우선순위
			: 우선순위가 높은 연산자에 대해 먼저 계산을 위해, 현재 스택의 최상위 노드를 스택에서 꺼내 해당 기호를 변환 된 후위 표현식의 결과로서 출력
			(단, 현재 스택의 최상의 노드의 기호가 '(' 일 경우, 변환 된 후위 표현식의 결과로서 출력하지 않음)

			3-3-2) 현재 스택의 최상위 노드의 기호 타입에 대한 우선순위 < 현재 분리 된 토큰의 기호 타입에 대한 우선순위
			: 우선순위가 높은 기호에 대해 먼저 계산을 위해 후위 표현식의 결과로서 출력 위한 판별 중지

		3-4) 피연산자 (정수 혹은 '.'을 포함 한 실수), ' ' (피연산자 간 구분을 위한 공백) 인 경우
		: 현재 분리 된 토큰의 기호를 스택에 삽입하지 않고 즉시 변환 된 후위 표현식의 결과로서 출력

		3-5) '.' (실수 표현을 위한 점) 인 경우
		: '.'은 단일 토큰으로서 처리 되지 않으며, '.'을 포함 한 실수로서 하나의 피연산자로 처리되어야만 함
		이에 따라, 논리 예외 발생

	4) 현재 중위 표현식에 더 이상 토큰으로 분리 할 것이 없으면, 스택에 남은 노드의 기호들을 순차적으로 모두 변환 된 후위 표현식의 결과로서 출력
	: 올바른 중위 표현식은 항상 '('와 ')'의 쌍이 일치 (개수가 일치)해야만 히며, 중위 표현식을 후위 표현식으로 변환하는 과정에서 ')'가 나올 경우, 
	'('가 나올 때 까지 후위 표현식에 출력하므로, 현재 스택에 남은 노드들 중 '('이 존재 할 경우, 잘못 된 중위 표현식 예외 발생

## < 후위 표현식에 대한 처리 및 계산 >

> 후위 표현식 : 중위 표현식으로부터 '(', ')' 및 연산자 우선순위에 따라 변환

> '.'을 포함하는 실수의 경우 '.'과 피연산자를 포함한 실수를 하나의 피연산자 토큰으로 처리하였으므로, 2-2에서 처리

	ex)
	중위 표현식 : ((1 - 2 * 2) + 1) * 3
	변환 된 후위 표현식 : 122*-1+3*

	1) 왼쪽부터 순차적으로 토큰 분리 (피연산자 간 구분을 위한 공백, 피연산자, 연산자)

	2) 분리 된 토큰의 기호 타입에 따라,
		2-1) 피연산자 간 구분을 위한 공백인 경우
		: 계산 시에 사용하지 않으므로, 해당 토큰 무시

		2-2) 피연산자인 경우
		: 토큰을 스택에 삽입

		2-3) 연산자인 경우
		: 스택에 존재하는 피연산자를 2회 꺼낸 후 피연산자에 대해 역순으로 현재 토큰의 연산자와 계산 수행 및 계산 결과를 다시 스택에 삽입
		단, 올바른 후위 표현식은 분리 된 토큰이 연산자인 상황에서 계산을 위해 스택에서 2회 꺼냈을 시, 항상 피연산자가 2회 연속으로 나타나야 함
		이에 따라, 스택에서 노드를 2회 꺼낼 수 없을 경우 (ex : 1*+2), 잘못 된 후위 표현식 예외 발생

	3) 후위 표현식을 끝까지 읽었을 경우 현재 스택에 남아있는 최종 계산 결과 반환